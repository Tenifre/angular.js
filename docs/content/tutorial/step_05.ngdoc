@ngdoc overview
@name Tutorial: 5 - XHRs & Dependency Injection
@description

<ul doc-tutorial-nav="5"></ul>

アプリケーションを作るにはハードコーディングされた３つの電話番号データセットがあれば十分! 一緒に私のサーバで使っていてangularで用意されている組み込み{@link api/ng services}、{@link api/ng.$http $http} を見てみよう。

今回私たちは angularの{@link guide/di dependency
injection (DI)}として用意されている PhoneListCtrl を使います。

<div doc-tutorial-reset="5"></div>

あなたは２０個のphone配列を見ます。それらはリストの前の重要な変更です。diffはこちらで見れます {@link
https://github.com/angular/angular-phonecat/compare/step-4...step-5
GitHub}:


## Data

あなたのプロジェクトの中に比較的大きいphone配列がJSON formatで記述されている app/phones/phones.json ファイルがあります。このファイルを見てみましょう:

<pre>
[
 {
  "age": 13,
  "id": "motorola-defy-with-motoblur",
  "name": "Motorola DEFY\u2122 with MOTOBLUR\u2122",
  "snippet": "Are you ready for everything life throws your way?"
  ...
 },
...
]
</pre>


## Controller

私達はあなたのWEBサーバ上にある app/phones/phones.json ファイルをHTTPリクエストでフェッチするために angular の {@link api/ng.$http $http}サービスを使います。`$http` は 数あるbuilt-in {@link api/ng angular services}の一般的なオペレーションです。Angularはあなたが必要なときに導入します。
サービスは angularの {@link guide/di DI subsystem} から管理されています。

__`app/js/controllers.js:`__
<pre>
function PhoneListCtrl($scope, $http) {
  $http.get('phones/phones.json').success(function(data) {
    $scope.phones = data;
  });

  $scope.orderProp = 'age';
}

//PhoneListCtrl.$inject = ['$scope', '$http'];
</pre>

`$http` が私のWEBサーバから HTTP GET request を行います。対象は phone/phones.jsonファイルで(このURLは`index.html`ファイルからの相対パスとして解決されます)サーバのレスポンスはJSONファイルとして提供されます(そのレスポンスはおそらくバックエンドのサーバで動的生成されるはずです。ブラウザと私のアプリケーションではいくつかそうしてます。このチュートリアルでは話を単純にするためJSONファイルになっています)

`$http`サービスは`success`付き{@link api/ng.$q promise object}を返します。私達はこのコントローラーからスコープ内にあるphone dataをphonesデータ形式で非同期通信で呼びます。
注意：angularは検出されたJSONを自分でパースします！
angular内のサービスで使っています。あなたは単に依存したい引数の名前を宣言するだけで以下のようにコントローラーのコンストラクタで宣言されます:

    function PhoneListCtrl($scope, $http) {...}

あなたのコントローラー上にあるコンストラクタの処理が始まった時にAngular の dependency injector が実行されます。このDIはほかの依存ライブラリの作成も行うかもしれません。引数の名前は重要です。なぜならばインスペクタがルックアップするためにこれらを使用しているからです。


<img  class="diagram" src="img/tutorial/xhr_service_final.png">


### '$' Prefix Naming Convention

あなたはあなた独自のサービスを作ることができます。そしてstep11にそのことが書いてあります。conventionの名前は angular の built-in services のことです。 スコープメソッドと新しいいくつかのAPIは '$'プレフィックスが前に付きます。あなたのサービスとモジュール名に'$'プレフィックを使ってはいけません、
名前の衝突を防ぐためにです。


### A Note on Minification

引数名をそのままコンストラクタに注入します。
もしあなたは {@link http://en.wikipedia.org/wiki/Minification_(programming)
minify} の `PhoneListCtrl` controller への JavaScript code をかくなら、すべての関数引数は minified されている必要があります。そして dependency injector がサービスを識別することができるようにします。minification によって起こる問題を克服するために、文字列配列型の`$inject`プロパティが用意しています。ちょうどこんなふうに使います:

    PhoneListCtrl.$inject = ['$scope', '$http'];

これらはdependencyリストとその他minificationの問題([]で注入する関数を文字列を囲むこと(依存関係を表します))。以下がインジェクトされたコードです。

    var PhoneListCtrl = ['$scope', '$http', function($scope, $http) { /* constructor body */ }];

両方のメソッドはAngularからインジェクトされた関数として動きます。この書き方はあなたの参加しているプロジェクトで用意されているガイドを使います

## Test

__`test/unit/controllersSpec.js`:__

私達はdependency injectionとコントローラーの依存関係を開始します、私達のテストコードはもう少し複雑な生成をします
私達はnew演算子とコンストラクタに付いているニセの`$http`を実装します。
しかしながら、オススメ（かつ簡単）なコントローラーのテスト環境の生成方法は、本番のコードの後ろに書くことです。
以下のようになります。

<pre>
describe('PhoneCat controllers', function() {

  describe('PhoneListCtrl', function(){
    var scope, ctrl, $httpBackend;

    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/phones.json').
          respond([{name: 'Nexus S'}, {name: 'Motorola DROID'}]);

      scope = $rootScope.$new();
      ctrl = $controller(PhoneListCtrl, {$scope: scope});
    }));
</pre>

注意： 私のテスト環境内の`angular-mocks.js`と Jasmineを読み込んでいます、私たちは２つのヘルパーメソッド{@link api/angular.mock.module module} と {@link api/angular.mock.inject inject} をつかってアクセスと設定を行います
私達はテスト環境がはいったコントローラーを以下のように作ります：

* 私達は使います `inject` helper method を次のなかからインジェクトします
{@link api/ng.$rootScope $rootScope},
{@link api/ng.$controller $controller} and
{@link api/ng.$httpBackend $httpBackend} Jasmine の `beforeEach`
functionへのサービス

このインスペクタからくるインスタンスはテストごとに再生性されます。
この生成、それぞれのテストが既知の開始ポイントから始まること、それぞれのテストが分離して動きます



* 私達は`$rootScope.$new()` からの呼び出しで新しいスコープを生成します

* 私達は`PhoneListCtrl`関数が通るインジェクトされた `$controller`を呼んだのとパラメータを生成します

* なぜならばコントローラー内のphoneリストデータをフェッチするのに`$http`のコードを使っている、
そのあと私たちは`PhoneListCtrl`を子スコープで生成し、必要な電話番号のテストをコントローラーにリクエストしています。

*`$httpBackend`リクエストは`beforeEach`関数へインジェクトします。これは本番環境でXHRとJSONPリクエストのモックバージョンです。このモックは常にネイティブAPIとグローバルに関連付けられている書き込みテストを行います。ーどちらもテストを行うのは大変ですね。


* `$httpBackend.expectGET`メソッドをHTTP requestがくることを期待して`$httpBackend` serviceにつなげるのとレスポンスがくるようにします。注意：そのレスポンスは一度も`$httpBackend.flush` methodをコールしていないこと。

今、我々はレスポンスを受け取る前にscope上に存在するphonesデータチェックした:

<pre>
    it('should create "phones" model with 2 phones fetched from xhr', function() {
      expect(scope.phones).toBeUndefined();
      $httpBackend.flush();

      expect(scope.phones).toEqual([{name: 'Nexus S'},
                                   {name: 'Motorola DROID'}]);
    });
</pre>

* 私達が`$httpBackend.flush()`から呼ばれたリクエストをフラッシュした。このケースは`$http`サービスがレスポンスをつけて解決することを約束します

* 私達は確認します、スコープ上にphoneデータが存在しているかを。

最後に我々は`orderProp`の初期値が正しいか確認します

<pre>
    it('should set the default value of orderProp model', function() {
      expect(scope.orderProp).toBe('age');
    });
  });
});
</pre>

あなたはTestacular tab内の出力結果を確認しないといけません。

       Chrome 22.0: Executed 2 of 2 SUCCESS (0.028 secs / 0.007 secs)



# Experiments

* `index.html`の下から、表示されるphonesリストの`{{phones | json}}`バインディングを加えます。

* `PhoneListCtrl` controller内にある、電話番号の最初の５桁をレスポンスとして返します。$http callback内のコードは以下です：

         $scope.phones = data.splice(0, 5);


# Summary

今回学習したことはangular servicesを使う簡単な方法です（AngularのDIに感謝）{@link step_06 step 6}へ進みます、
次はサムネイルとリンクを加えます。

<ul doc-tutorial-nav="5"></ul>
